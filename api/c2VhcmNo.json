[{"title":"Shell 常用命令","date":"2022-04-04T18:00:00.000Z","date_formatted":{"ll":"Apr 4, 2022","L":"04/04/2022","MM-DD":"04-04"},"updated":"2022-04-04T14:16:50.576Z","content":"\nLinux常用的shell命令\n\n\n定义脚本外参数\n1234#!/bin/bash# 如：./shell.sh 参数1 参数2var1=$1var2=$2\n判断命令执行是否成功\n1234567#!/bin/bashdocker load -i $&#123;service&#125;.tarif [ $? -ne 0 ]; then    echo &quot;failed load $&#123;service&#125;&quot; &gt;&gt; loadImage.txtelse    echo &quot;succeed load $&#123;service&#125;&quot; &gt;&gt; loadImage.txtfi\n定义数组\n12345service_array=(data1 data2)for service in $&#123;service_array[@]&#125;do    echo &quot; 【$&#123;service&#125;】 服务&quot;done\n获取命令执行返回的第几列\n123456# 获取并赋值# service_pod_ids=(data1 data2 data2)service_pod_ids=$(echo `kubectl get pods -n light |grep $&#123;service&#125; |awk &#x27;&#123;print $1&quot; &quot;&#125;&#x27;`)# 获取到数组第一位数 # service_pod_id_1=data1service_pod_id_1=$(echo $service_pod_ids |awk &#x27;&#123;print $1&#125;&#x27;)\n远程到其它服务器执行命令\n1sshpass -p &quot;$&#123;password&#125;&quot; ssh -o StrictHostKeyChecking=no root@$&#123;ip&#125; &quot;echo &#x27;命令&#x27;&quot;\n等待执行\n123456789101112echo &quot;wait 10s&quot;    d=`date +%s`    while true    do    e=`date +%s`    f=`expr $e - $d`    echo $f    if [ $f -gt 10 ];then        break    fi    sleep 10    done\n创建文件\n1touch loadImage.txt\n写入文件内容\n1echo &quot;failed push $&#123;service&#125;&quot; &gt;&gt; loadImage.txt\n授权\n12chmod 777 xxx.shchmod a+r file\n符号模式\n使用符号模式可以设置多个项目：who（用户类型），operator（操作符）和 permission（权限），每个项目的设置可以用逗号隔开。 命令 chmod 将修改 who 指定的用户类型对文件的访问权限，用户类型由一个或者多个字母在 who 的位置来说明，如 who 的符号模式表所示:\n\n\nwho\n用户类型\n说明\n\n\n\n\nu\nuser\n文件所有者\n\n\ng\ngroup\n文件所有者所在组\n\n\no\nothers\n所有其他用户\n\n\na\nall\n所用用户, 相当于 ugo\n\n\noperator 的符号模式表:\n\n\nOperator\n说明\n\n\n\n\n+\n为指定的用户类型增加权限\n\n\n-\n去除指定用户类型的权限\n\n\n=\n设置指定用户权限的设置，即将用户类型的所有权限重新设置\n\n\npermission 的符号模式表:\n\n\n模式\n名字\n说明\n\n\n\n\nr\n读\n设置为可读权限\n\n\nw\n写\n设置为可写权限\n\n\nx\n执行权限\n设置为可执行权限\n\n\nX\n特殊执行权限\n只有当文件为目录文件，或者其他类型的用户有可执行权限时，才将文件权限设置可执行\n\n\ns\nsetuid/gid\n当文件被执行时，根据who参数指定的用户类型设置文件的setuid或者setgid权限\n\n\nt\n粘贴位\n设置粘贴位，只有超级用户可以设置该位，只有文件所有者u可以使用该位\n\n\n八进制语法\nchmod命令可以使用八进制数来指定权限。文件或目录的权限位是由9个权限位来控制，每三位为一组，它们分别是文件所有者（User）的读、写、执行，用户组（Group）的读、写、执行以及其它用户（Other）的读、写、执行。历史上，文件权限被放在一个比特掩码中，掩码中指定的比特位设为1，用来说明一个类具有相应的优先级。\n\n\n#\n权限\nrwx\n二进制\n\n\n\n\n7\n读 + 写 + 执行\nrwx\n111\n\n\n6\n读 + 写\nrw-\n110\n\n\n5\n读 + 执行\nr-x\n101\n\n\n4\n只读\nr–\n100\n\n\n3\n写 + 执行\n-wx\n011\n\n\n2\n只写\n-w-\n010\n\n\n1\n只执行\n–x\n001\n\n\n0\n无\n—\n000\n\n\n例如， 765 将这样解释：\n\n\n所有者的权限用数字表达：属主的那三个权限位的数字加起来的总和。如 rwx ，也就是 4+2+1 ，应该是 7。\n\n\n用户组的权限用数字表达：属组的那个权限位数字的相加的总和。如 rw- ，也就是 4+2+0 ，应该是 6。\n\n\n其它用户的权限数字表达：其它用户权限位的数字相加的总和。如 r-x ，也就是 4+0+1 ，应该是 5。\n\n\n格式脚本\n1dos2unix  service_up.sh\n后台运行\n1nohup sh xxx.sh &gt;xx.log 2&gt;&amp;1 &amp;\nk8s实时显示\n1watch kubectl get pods -n light\ncurl\n1curl -s -w &quot;time_connect: %&#123;time_connect&#125;\\ntime_starttransfer: %&#123;time_starttransfer&#125;\\ntime_nslookup:%&#123;time_namelookup&#125;\\ntime_total: %&#123;time_total&#125;\\n&quot; http://iam-gateway.keycloak.svc.cluster.local:8080/managers -H &quot;Host: iam-gateway.keycloak.svc.cluster.local&quot; --header &quot;Authorization: Bearer eyJhbGciOiJSUzI1NiIsInR5cCIgOiAiSldUIiwia2lkIiA6ICJXX0tSNUJJcEJ1dURjZEI4RThxYmdDcjBtUmRyYmZfa0Z0MVB6VTMxNWM0In0.eyJleHAiOjE2MTU0MzE4NDYsImlhdCI6MTYxNTQzMTQyNiwianRpIjoiZGY5NDQ0ZGYtMDg0OS00MmY2LTk0MGUtOGQ4OTVkNGRiY2Y0IiwiaXNzIjoiaHR0cDovL2tleWNsb2FrLWh0dHAua2V5Y2xvYWsuc3ZjLmNsdXN0ZXIubG9jYWwvYXV0aC9yZWFsbXMvYXV0aHoiLCJhdWQiOlsiaWFtIiwiYWNjb3VudCJdLCJzdWIiOiJjZDcyNmNhYS1kMWU2LTQzYjMtYTYxMi1jNmY1YjE5NWJiYWUiLCJ0eXAiOiJCZWFyZXIiLCJhenAiOiJpYW0iLCJzZXNzaW9uX3N0YXRlIjoiZWVmZjk3NTgtMmQ5MC00ZWJjLWEzY2YtNzMwZDRkZGM3YjRmIiwiYWNyIjoiMSIsInJlYWxtX2FjY2VzcyI6eyJyb2xlcyI6WyJvZmZsaW5lX2FjY2VzcyIsInVtYV9hdXRob3JpemF0aW9uIiwicmVhbG0tbWFuYWdlciJdfSwicmVzb3VyY2VfYWNjZXNzIjp7ImFjY291bnQiOnsicm9sZXMiOlsibWFuYWdlLWFjY291bnQiLCJtYW5hZ2UtYWNjb3VudC1saW5rcyIsInZpZXctcHJvZmlsZSJdfX0sInNjb3BlIjoicHJvZmlsZSB0ZW5hbnQgZW1haWwgZ3JvdXAiLCJlbWFpbF92ZXJpZmllZCI6ZmFsc2UsInByZWZlcnJlZF91c2VybmFtZSI6Im1lc2giLCJsb2NhbGUiOiJ6aC1DTiJ9.m5lD8PUNP4aLuVSL_8KnGUSitt0388WK8S5TH63yP7hkYJ3Xc9eG-uw8jemWYrvDjThUFwdg-iGp7j7D8LnHauiLYMamo_5zyFu8ryLJxMHg-d7wWK0EeaEmA5YoM7QLPZ_FgXTFbeBV50k-KTMFJ3yhJw4LdpQL2YxRxrNli7_Omjkz10brtRsKWxR9VpAnoYMcguqAsRIpUa-VGcGz4fiFcrBxlS_lXMmhJGTdtjRSylKE4BLNz8YwWuMkOQi-KSxZqWSUiJ3Brav3vr6WYVYqGGh-Sughr3_kozfXz7lYxiBJjgWuZWa87x4SZiKaXlNn0G6J4MU2TdtFZ1Y31A&quot;\ndocker 删除none镜像\n1docker images |grep none |awk &#x27;&#123;print $3&#125;&#x27;|xargs docker rmi\ntail\n12tail -f tail -f100 \n查询路由route\n1route -n\n通过国际公认时间服务同步集群时钟\n12ntpdate -u net.api.bz#可以使用linux定时任务crond 定时同步\n查看Linux内核版本命令（两种方法）：\n121、cat /proc/version2、uname -a\ntar 压缩/减压缩\n123456# 压缩tar 如果压缩地址是全地址会将全路径压缩进压缩包中cd $&#123;build_path&#125;tar -zcvf $&#123;project_name&#125;.tar.gz $&#123;project_name&#125;# 解压到go工作目录tar -zxvf $&#123;boot_path&#125;&quot;/&quot;$&#123;project_name&#125;.tar.gz -C $&#123;deploy_path&#125;\n判断语句if\n12345678910111213141516171819#Boolean类型判断if test &quot;$is_build&quot; = &quot;false&quot; ; then    echo &quot;构建已完成! $project_name&quot;    #退出    exit 0fi# 判断命令是否执行成功    if [ $? -ne 0 ]; then        echo &quot;build $&#123;project_name&#125; failed!&quot;        exit 1    else        echo &quot;build $&#123;project_name&#125; succeed!&quot;    fi#判断文件夹是否需要创建if [ ! -d &quot;$&#123;build_project_path&#125;&quot; ];then    mkdir -p $&#123;build_project_path&#125;else    echo &quot;目录$&#123;build_project_path&#125;文件夹已经存在！&quot;fi\n执行返回作为变量\n12345678910#清理镜像echo &quot;docker images | grep $harbor_project/$project_name |grep none&quot;images_none=`docker images | grep $harbor_project/$project_name |grep none`if [ ! -n &quot;$images_none&quot; ]; then #判断是否为空  echo &quot;images none IS NULL&quot;else  echo &quot;$images_none&quot;  echo &quot;docker images | grep $harbor_project/$project_name |grep none |awk &#x27;&#123;print \\$3&#125;&#x27;|xargs docker rmi&quot;  docker images | grep $harbor_project/$project_name |grep none |awk &quot;&#123;print \\$3&#125;&quot;|xargs docker rmifi\nshell脚本粘贴错行\n123vim xxx.sh:set paste#然后 i, 如何粘贴\nLinux查询内核信息\n1uname -a\n字符串包含\n123456decollator1=&quot;===========&quot;if [[ $str == *$decollator1* ]]then    echo &quot;包含&quot;    continuefi\n数组定义\n1234key=()for v in $&#123;arrays[@]&#125;; do  key[$&#123;#key[*]&#125;]=$&#123;v&#125;done\n字符串分割成数组\n12str=&quot;1111 3333 444&quot;arrays=($&#123;str//\\n/&#125;)\n定义参数输入调用函数\n1234567891011121314151617181920COMMAND=$&#123;1&#125;help()&#123;    #echo &quot;$&#123;0&#125; &lt;start|stop|restart|status&gt;&quot;    #echo &quot;help&quot;    echo &quot;$&#123;0&#125; &lt;report&gt;&quot;    exit 1&#125;case $&#123;COMMAND&#125; in  (help)    help    ;;  (report)    report    ;;  (*)    echo &quot;help $&#123;COMMAND&#125;&quot;    help    ;;esac\nopenssl命令\n12345678910111213141516171819sha256()&#123; # sha256sum 加密\tstr=`echo -n &quot;$&#123;1&#125;&quot; | sha256sum`\tstrArr=($str)\tstr=$&#123;strArr[0]&#125;\techo $str&#125;hmac_hexkey()&#123; # hmac加密 hexkey是十六进制值\tstr=`echo -n &quot;$&#123;2&#125;&quot; | openssl dgst -sha256 -mac HMAC -macopt hexkey:&quot;$&#123;1&#125;&quot;`\tstrArr=($str)\tstr=$&#123;strArr[1]&#125;\techo &quot;$str&quot;&#125;hmac_key()&#123;# hmac加密 key常规数据\tstr=`echo -n &quot;$&#123;2&#125;&quot; | openssl dgst -sha256 -mac HMAC -macopt key:&quot;$&#123;1&#125;&quot;`\tstrArr=($str)\tstr=$&#123;strArr[1]&#125;\techo &quot;$str&quot;&#125;\n","thumbnail":"img/coding-1.jpeg","color":"#111","plink":"https://liuzy.love/2022/04/04/shell/Shell常用命令/"},{"title":"第一部分-初始go","date":"2022-02-15T18:00:00.000Z","date_formatted":{"ll":"Feb 15, 2022","L":"02/15/2022","MM-DD":"02-15"},"updated":"2022-04-04T14:16:50.572Z","content":"\ngolang语言技术栈知识总结\n\n\n初识GO\n调试源代码\n1234567891011$ cat main.gopackage mainimport &quot;fmt&quot;func main() &#123;\tfmt.Println(&quot;Hello World&quot;) //控制台打印 Hello World&#125;$ $GOPATH/src/github.com/golang/go/bin/go run main.go //编译go 二进制文件dravenHello World // 输出的结果\n","thumbnail":"img/v06.jpeg","color":"#111","plink":"https://liuzy.love/2022/02/15/go/go语言设计与实现/第一部分-初始go/"},{"title":"入门模板","date":"2022-02-11T18:00:00.000Z","date_formatted":{"ll":"Feb 11, 2022","L":"02/11/2022","MM-DD":"02-11"},"updated":"2022-04-04T14:16:50.576Z","content":"\n我们理解您需要更便捷更高效的工具记录思想，整理笔记、知识，并将其中承载的价值传播给他人，Cmd Markdown 是我们给出的答案 —— 我们为记录思想和分享知识提供更专业的工具。 您可以使用 Cmd Markdown：\n\n\n欢迎使用 Cmd Markdown 编辑阅读器\n\n我们理解您需要更便捷更高效的工具记录思想，整理笔记、知识，并将其中承载的价值传播给他人，Cmd Markdown 是我们给出的答案 —— 我们为记录思想和分享知识提供更专业的工具。 您可以使用 Cmd Markdown：\n\n\n整理知识，学习笔记\n发布日记，杂文，所见所想\n撰写发布技术文稿（代码支持）\n撰写发布学术论文（LaTeX 公式支持）\n\n\n\n除了您现在看到的这个 Cmd Markdown 在线版本，您还可以前往以下网址下载：\nWindows/Mac/Linux 全平台客户端\n\n请保留此份 Cmd Markdown 的欢迎稿兼使用说明，如需撰写新稿件，点击顶部工具栏右侧的  新文稿 或者使用快捷键 Ctrl+Alt+N。\n\n\n什么是 Markdown\nMarkdown 是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档：譬如您正在阅读的这份文档。它使用简单的符号标记不同的标题，分割不同的段落，粗体 或者 斜体 某些文字，更棒的是，它还可以\n1. 制作一份待办事宜 Todo 列表\n\n支持以 PDF 格式导出文稿\n改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率\n新增 Todo 列表功能\n修复 LaTex 公式渲染问题\n新增 LaTex 公式编号功能\n\n2. 书写一个质能守恒公式[^LaTeX]\n$$E=mc^2$$\n3. 高亮一段代码[^code]\n1234567@requires_authorizationclass SomeClass:    pass if __name__ == &#x27;__main__&#x27;:    # A comment    print &#x27;hello world&#x27;\n4. 高效绘制 流程图\n12345678st=&gt;start: Startop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?e=&gt;end st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op\n5. 高效绘制 序列图\n123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks!\n6. 高效绘制 甘特图\n12345678910111213title 项目开发流程section 项目确定    需求分析       :a1, 2016-06-22, 3d    可行性报告     :after a1, 5d    概念验证       : 5dsection 项目实施    概要设计      :2016-07-05  , 5d    详细设计      :2016-07-08, 10d    编码          :2016-07-15, 10d    测试          :2016-07-22, 5dsection 发布验收    发布: 2d    验收: 3d\n7. 绘制表格\n\n\n项目\n价格\n数量\n\n\n\n\n计算机\n$1600\n5\n\n\n手机\n$12\n12\n\n\n管线\n$1\n234\n\n\n8. 更详细语法说明\n想要查看更详细的语法说明，可以参考我们准备的 Cmd Markdown 简明语法手册，进阶用户可以参考 Cmd Markdown 高阶语法手册 了解更多高级功能。\n总而言之，不同于其它 所见即所得 的编辑器：你只需使用键盘专注于书写文本内容，就可以生成印刷级的排版格式，省却在键盘和工具栏之间来回切换，调整内容和格式的麻烦。Markdown 在流畅的书写和印刷级的阅读体验之间找到了平衡。 目前它已经成为世界上最大的技术分享网站 GitHub 和 技术问答网站 StackOverFlow 的御用书写格式。\n\n什么是 Cmd Markdown\n您可以使用很多工具书写 Markdown，但是 Cmd Markdown 是这个星球上我们已知的、最好的 Markdown 工具——没有之一 ：）因为深信文字的力量，所以我们和你一样，对流畅书写，分享思想和知识，以及阅读体验有极致的追求，我们把对于这些诉求的回应整合在 Cmd Markdown，并且一次，两次，三次，乃至无数次地提升这个工具的体验，最终将它演化成一个 编辑/发布/阅读 Markdown 的在线平台——您可以在任何地方，任何系统/设备上管理这里的文字。\n1. 实时同步预览\n我们将 Cmd Markdown 的主界面一分为二，左边为编辑区，右边为预览区，在编辑区的操作会实时地渲染到预览区方便查看最终的版面效果，并且如果你在其中一个区拖动滚动条，我们有一个巧妙的算法把另一个区的滚动条同步到等价的位置，超酷！\n2. 编辑工具栏\n也许您还是一个 Markdown 语法的新手，在您完全熟悉它之前，我们在 编辑区 的顶部放置了一个如下图所示的工具栏，您可以使用鼠标在工具栏上调整格式，不过我们仍旧鼓励你使用键盘标记格式，提高书写的流畅度。\n\n3. 编辑模式\n完全心无旁骛的方式编辑文字：点击 编辑工具栏 最右侧的拉伸按钮或者按下 Ctrl + M，将 Cmd Markdown 切换到独立的编辑模式，这是一个极度简洁的写作环境，所有可能会引起分心的元素都已经被挪除，超清爽！\n4. 实时的云端文稿\n为了保障数据安全，Cmd Markdown 会将您每一次击键的内容保存至云端，同时在 编辑工具栏 的最右侧提示 已保存 的字样。无需担心浏览器崩溃，机器掉电或者地震，海啸——在编辑的过程中随时关闭浏览器或者机器，下一次回到 Cmd Markdown 的时候继续写作。\n5. 离线模式\n在网络环境不稳定的情况下记录文字一样很安全！在您写作的时候，如果电脑突然失去网络连接，Cmd Markdown 会智能切换至离线模式，将您后续键入的文字保存在本地，直到网络恢复再将他们传送至云端，即使在网络恢复前关闭浏览器或者电脑，一样没有问题，等到下次开启 Cmd Markdown 的时候，她会提醒您将离线保存的文字传送至云端。简而言之，我们尽最大的努力保障您文字的安全。\n6. 管理工具栏\n为了便于管理您的文稿，在 预览区 的顶部放置了如下所示的 管理工具栏：\n\n通过管理工具栏可以：\n 发布：将当前的文稿生成固定链接，在网络上发布，分享\n 新建：开始撰写一篇新的文稿\n 删除：删除当前的文稿\n 导出：将当前的文稿转化为 Markdown 文本或者 Html 格式，并导出到本地\n 列表：所有新增和过往的文稿都可以在这里查看、操作\n 模式：切换 普通/Vim/Emacs 编辑模式\n7. 阅读工具栏\n\n通过 预览区 右上角的 阅读工具栏，可以查看当前文稿的目录并增强阅读体验。\n工具栏上的五个图标依次为：\n 目录：快速导航当前文稿的目录结构以跳转到感兴趣的段落\n 视图：互换左边编辑区和右边预览区的位置\n 主题：内置了黑白两种模式的主题，试试 黑色主题，超炫！\n 阅读：心无旁骛的阅读模式提供超一流的阅读体验\n 全屏：简洁，简洁，再简洁，一个完全沉浸式的写作和阅读环境\n8. 阅读模式\n在 阅读工具栏 点击  或者按下 Ctrl+Alt+M 随即进入独立的阅读模式界面，我们在版面渲染上的每一个细节：字体，字号，行间距，前背景色都倾注了大量的时间，努力提升阅读的体验和品质。\n9. 标签、分类和搜索\n在编辑区任意行首位置输入以下格式的文字可以标签当前文档：\n标签： 未分类\n标签以后的文稿在【文件列表】（Ctrl+Alt+F）里会按照标签分类，用户可以同时使用键盘或者鼠标浏览查看，或者在【文件列表】的搜索文本框内搜索标题关键字过滤文稿，如下图所示：\n\n10. 文稿发布和分享\n在您使用 Cmd Markdown 记录，创作，整理，阅读文稿的同时，我们不仅希望它是一个有力的工具，更希望您的思想和知识通过这个平台，连同优质的阅读体验，将他们分享给有相同志趣的人，进而鼓励更多的人来到这里记录分享他们的思想和知识，尝试点击  (Ctrl+Alt+P) 发布这份文档给好友吧！\n\n再一次感谢您花费时间阅读这份欢迎稿，点击  (Ctrl+Alt+N) 开始撰写新的文稿吧！祝您在这里记录、阅读、分享愉快！\n作者 @ghosert\n2016 年 07月 07日\n[^LaTeX]: 支持 LaTeX 编辑显示支持，例如：$\\sum_{i=1}^n a_i=0$， 访问 MathJax 参考更多使用方法。\n[^code]: 代码高亮功能支持包括 Java, Python, JavaScript 在内的，四十一种主流编程语言。\n","thumbnail":"img/v01.jpeg","color":"#111","plink":"https://liuzy.love/2022/02/11/markdown/入门模板/"},{"title":"简单模板","date":"2022-02-11T18:00:00.000Z","date_formatted":{"ll":"Feb 11, 2022","L":"02/11/2022","MM-DD":"02-11"},"updated":"2022-04-04T14:16:50.576Z","content":"\n本Markdown编辑器使用StackEdit修改而来，用它写博客，将会带来全新的体验哦：\n\n\n欢迎使用Markdown编辑器写博客\n本Markdown编辑器使用StackEdit修改而来，用它写博客，将会带来全新的体验哦：\n\nMarkdown和扩展Markdown简洁的语法\n代码块高亮\n图片链接和图片上传\nLaTex数学公式\nUML序列图和流程图\n离线写博客\n导入导出Markdown文件\n丰富的快捷键\n\n\n快捷键\n\n加粗    Ctrl + B\n斜体    Ctrl + I\n引用    Ctrl + Q\n插入链接    Ctrl + L\n插入代码    Ctrl + K\n插入图片    Ctrl + G\n提升标题    Ctrl + H\n有序列表    Ctrl + O\n无序列表    Ctrl + U\n横线    Ctrl + R\n撤销    Ctrl + Z\n重做    Ctrl + Y\n\nMarkdown及扩展\n\nMarkdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。    ——  [ 维基百科 ]\n\n使用简单的符号标识不同的标题，将某些文字标记为粗体或者斜体，创建一个链接等，详细语法参考帮助？。\n本编辑器支持 Markdown Extra , 　扩展了很多好用的功能。具体请参考Github.\n表格\nMarkdown　Extra　表格语法：\n\n\n项目\n价格\n\n\n\n\nComputer\n$1600\n\n\nPhone\n$12\n\n\nPipe\n$1\n\n\n可以使用冒号来定义对齐方式：\n\n\n项目\n价格\n数量\n\n\n\n\nComputer\n1600 元\n5\n\n\nPhone\n12 元\n12\n\n\nPipe\n1 元\n234\n\n\n###定义列表\nMarkdown　Extra　定义列表语法：\n项目１\n项目２\n:   定义 A\n:   定义 B\n项目３\n:   定义 C\n:   定义 D\n&gt; 定义D内容\n\n代码块\n代码块语法遵循标准markdown代码，例如：\n12345678910@requires_authorizationdef somefunc(param1=&#x27;&#x27;, param2=0):    &#x27;&#x27;&#x27;A docstring&#x27;&#x27;&#x27;    if param1 &gt; param2: # interesting        print &#x27;Greater&#x27;    return (param2 - param1 + 1) or Noneclass SomeClass:    pass&gt;&gt;&gt; message = &#x27;&#x27;&#x27;interpreter... prompt&#x27;&#x27;&#x27;\n###脚注\n生成一个脚注[^footnote].\n[^footnote]: 这里是 脚注 的 内容.\n目录\n用 [TOC]来生成目录：\n[TOC]\n数学公式\n使用MathJax渲染LaTex 数学公式，详见math.stackexchange.com.\n\n行内公式，数学公式为：$\\Gamma(n) = (n-1)!\\quad\\forall n\\in\\mathbb N$。\n块级公式：\n\n$$\tx = \\dfrac{-b \\pm \\sqrt{b^2 - 4ac}}{2a} $$\n更多LaTex语法请参考 这儿.\nUML 图:\n可以渲染序列图：\n123张三-&gt;李四: 嘿，小四儿, 写博客了没?Note right of 李四: 李四愣了一下，说：李四--&gt;张三: 忙得吐血，哪有时间写。\n或者流程图：\n12345678st=&gt;start: 开始e=&gt;end: 结束op=&gt;operation: 我的操作cond=&gt;condition: 确认？st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op\n\n关于 序列图 语法，参考 这儿,\n关于 流程图 语法，参考 这儿.\n\n离线写博客\n即使用户在没有网络的情况下，也可以通过本编辑器离线写博客（直接在曾经使用过的浏览器中输入write.blog.csdn.net/mdeditor即可。Markdown编辑器使用浏览器离线存储将内容保存在本地。\n用户写博客的过程中，内容实时保存在浏览器缓存中，在用户关闭浏览器或者其它异常情况下，内容不会丢失。用户再次打开浏览器时，会显示上次用户正在编辑的没有发表的内容。\n博客发表后，本地缓存将被删除。\n用户可以选择  把正在写的博客保存到服务器草稿箱，即使换浏览器或者清除缓存，内容也不会丢失。\n\n**注意：**虽然浏览器存储大部分时候都比较可靠，但为了您的数据安全，在联网后，请务必及时发表或者保存到服务器草稿箱。\n\n##浏览器兼容\n\n目前，本编辑器对Chrome浏览器支持最为完整。建议大家使用较新版本的Chrome。\nIE９以下不支持\nIE９，１０，１１存在以下问题\n\n不支持离线功能\nIE9不支持文件导入导出\nIE10不支持拖拽文件导入\n\n\n\n\n","thumbnail":"img/v02.jpeg","color":"#111","plink":"https://liuzy.love/2022/02/11/markdown/简单模板/"},{"title":"语法示例大全","date":"2022-02-11T18:00:00.000Z","date_formatted":{"ll":"Feb 11, 2022","L":"02/11/2022","MM-DD":"02-11"},"updated":"2022-04-04T14:16:50.576Z","content":"\nMarkdown 简明语法手册\n\n\n『Cmd 技术渲染的沙箱页面，点击此处编写自己的文档』\nCmd Markdown 简明语法手册\n标签： Cmd-Markdown\n\n1. 斜体和粗体\n使用 * 和 ** 表示斜体和粗体。\n示例：\n这是 斜体，这是 粗体。\n2. 分级标题\n使用 === 表示一级标题，使用 — 表示二级标题。\n示例：\n1234567这是一个一级标题============================这是一个二级标题--------------------------------------------------### 这是一个三级标题\n你也可以选择在行首加井号表示不同级别的标题 (H1-H6)，例如：# H1, ## H2, ### H3，#### H4。\n3. 外链接\n使用 [描述](链接地址) 为文字增加外链接。\n示例：\n这是去往 本人博客 的链接。\n4. 无序列表\n使用 *，+，- 表示无序列表。\n示例：\n\n无序列表项 一\n无序列表项 二\n无序列表项 三\n\n5. 有序列表\n使用数字和点表示有序列表。\n示例：\n\n有序列表项 一\n有序列表项 二\n有序列表项 三\n\n6. 文字引用\n使用 &gt; 表示文字引用。\n示例：\n\n野火烧不尽，春风吹又生。\n\n7. 行内代码块\n使用 `代码` 表示行内代码块。\n示例：\n让我们聊聊 html。\n8.  代码块\n使用 四个缩进空格 表示代码块。\n示例：\n这是一个代码块，此行左侧有四个不可见的空格。\n\n9.  插入图像\n使用 ![描述](图片链接地址) 插入图像。\n示例：\n\nCmd Markdown 高阶语法手册\n1. 内容目录\n在段落中填写 [TOC] 以显示全文内容的目录结构。\n[TOC]\n2. 标签分类\n在编辑区任意行的列首位置输入以下代码给文稿标签：\n标签： 数学 英语 Markdown\n或者\nTags： 数学 英语 Markdown\n3. 删除线\n使用 ~~ 表示删除线。\n这是一段错误的文本。\n4. 注脚\n使用 [^keyword]: 表示注脚。\n这是一个注脚[^footnote]的样例。\n这是第二个注脚[^footnote2]的样例。\n5. LaTeX 公式\n$ 表示行内公式：\n质能守恒方程可以用一个很简洁的方程式 $E=mc^2$ 来表达。\n$$ 表示整行公式：\n$$\\sum_{i=1}^n a_i=0$$\n$$f(x_1,x_x,\\ldots,x_n) = x_1^2 + x_2^2 + \\cdots + x_n^2 $$\n$$\\sum^{j-1}{k=0}{\\widehat{\\gamma}{kj} z_k}$$\n访问 MathJax 参考更多使用方法。\n6. 加强的代码块\n支持四十一种编程语言的语法高亮的显示，行号显示。\n非代码示例：\n1$ sudo apt-get install vim-gnome\nPython 示例：\n123456789101112@requires_authorizationdef somefunc(param1=&#x27;&#x27;, param2=0):    &#x27;&#x27;&#x27;A docstring&#x27;&#x27;&#x27;    if param1 &gt; param2: # interesting        print &#x27;Greater&#x27;    return (param2 - param1 + 1) or Noneclass SomeClass:    pass&gt;&gt;&gt; message = &#x27;&#x27;&#x27;interpreter... prompt&#x27;&#x27;&#x27;\nJavaScript 示例：\n1234567891011121314151617/*** nth element in the fibonacci series.* @param n &gt;= 0* @return the nth element, &gt;= 0.*/function fib(n) &#123;  var a = 1, b = 1;  var tmp;  while (--n &gt;= 0) &#123;    tmp = a;    a += b;    b = tmp;  &#125;  return a;&#125;document.write(fib(10));\n7. 流程图\n示例\n12345678910st=&gt;start: Start:&gt;https://www.zybuluo.comio=&gt;inputoutput: verificationop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?sub=&gt;subroutine: Your Subroutinee=&gt;endst-&gt;io-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;sub-&gt;io\n更多语法参考：流程图语法参考\n8. 序列图\n示例 1\n123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks!\n示例 2\n12345Title: Here is a titleA-&gt;B: Normal lineB--&gt;C: Dashed lineC-&gt;&gt;D: Open arrowD--&gt;&gt;A: Dashed open arrow\n更多语法参考：序列图语法参考\n9. 甘特图\n甘特图内在思想简单。基本是一条线条图，横轴表示时间，纵轴表示活动（项目），线条表示在整个期间上计划和实际的活动完成情况。它直观地表明任务计划在什么时候进行，及实际进展与计划要求的对比。\n12345678910111213title 项目开发流程section 项目确定    需求分析       :a1, 2016-06-22, 3d    可行性报告     :after a1, 5d    概念验证       : 5dsection 项目实施    概要设计      :2016-07-05  , 5d    详细设计      :2016-07-08, 10d    编码          :2016-07-15, 10d    测试          :2016-07-22, 5dsection 发布验收    发布: 2d    验收: 3d\n更多语法参考：甘特图语法参考\n10. Mermaid 流程图\n1234A[Hard edge] --&gt;|Link text| B(Round edge)B --&gt; C&#123;Decision&#125;C --&gt;|One| D[Result one]C --&gt;|Two| E[Result two]\n更多语法参考：Mermaid 流程图语法参考\n11. Mermaid 序列图\n1234Alice-&gt;John: Hello John, how are you?loop every minute    John--&gt;Alice: Great!end\n更多语法参考：Mermaid 序列图语法参考\n12. 表格支持\n\n\n项目\n价格\n数量\n\n\n\n\n计算机\n$1600\n5\n\n\n手机\n$12\n12\n\n\n管线\n$1\n234\n\n\n13. 定义型列表\n名词 1\n:   定义 1（左侧有一个可见的冒号和四个不可见的空格）\n代码块 2\n:   这是代码块的定义（左侧有一个可见的冒号和四个不可见的空格）\n    代码块（左侧有八个不可见的空格）\n\n14. Html 标签\n本站支持在 Markdown 语法中嵌套 Html 标签，譬如，你可以用 Html 写一个纵跨两行的表格：\n&lt;table&gt;\n    &lt;tr&gt;\n        &lt;th rowspan=&quot;2&quot;&gt;值班人员&lt;/th&gt;\n        &lt;th&gt;星期一&lt;/th&gt;\n        &lt;th&gt;星期二&lt;/th&gt;\n        &lt;th&gt;星期三&lt;/th&gt;\n    &lt;/tr&gt;\n    &lt;tr&gt;\n        &lt;td&gt;李强&lt;/td&gt;\n        &lt;td&gt;张明&lt;/td&gt;\n        &lt;td&gt;王平&lt;/td&gt;\n    &lt;/tr&gt;\n&lt;/table&gt;\n\n\n    \n        值班人员\n        星期一\n        星期二\n        星期三\n    \n    \n        李强\n        张明\n        王平\n    \n\n15. 内嵌图标\n本站的图标系统对外开放，在文档中输入\n&lt;i class=&quot;icon-weibo&quot;&gt;&lt;/i&gt;\n\n即显示微博的图标： \n替换 上述 i 标签 内的 icon-weibo 以显示不同的图标，例如：\n&lt;i class=&quot;icon-renren&quot;&gt;&lt;/i&gt;\n\n即显示人人的图标： \n更多的图标和玩法可以参看 font-awesome 官方网站。\n16. 待办事宜 Todo 列表\n使用带有 [ ] 或 [x] （未完成或已完成）项的列表语法撰写一个待办事宜列表，并且支持子列表嵌套以及混用Markdown语法，例如：\n- [ ] **Cmd Markdown 开发**\n    - [ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率\n    - [ ] 支持以 PDF 格式导出文稿\n    - [x] 新增Todo列表功能 [语法参考](https://github.com/blog/1375-task-lists-in-gfm-issues-pulls-comments)\n    - [x] 改进 LaTex 功能\n        - [x] 修复 LaTex 公式渲染问题\n        - [x] 新增 LaTex 公式编号功能 [语法参考](http://docs.mathjax.org/en/latest/tex.html#tex-eq-numbers)\n- [ ] **七月旅行准备**\n    - [ ] 准备邮轮上需要携带的物品\n    - [ ] 浏览日本免税店的物品\n    - [x] 购买蓝宝石公主号七月一日的船票\n\n对应显示如下待办事宜 Todo 列表：\n\nCmd Markdown 开发\n\n改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率\n支持以 PDF 格式导出文稿\n新增Todo列表功能 语法参考\n改进 LaTex 功能\n\n修复 LaTex 公式渲染问题\n新增 LaTex 公式编号功能 语法参考\n\n\n\n\n七月旅行准备\n\n准备邮轮上需要携带的物品\n浏览日本免税店的物品\n购买蓝宝石公主号七月一日的船票\n\n\n\n[^footnote]: 这是一个 注脚 的 文本。\n[^footnote2]: 这是另一个 注脚 的 文本。\n","thumbnail":"img/v03.jpeg","color":"#111","plink":"https://liuzy.love/2022/02/11/markdown/语法示例大全/"},{"title":"Hexo","date":"2022-02-01T18:00:00.000Z","date_formatted":{"ll":"Feb 1, 2022","L":"02/01/2022","MM-DD":"02-01"},"updated":"2022-04-04T14:16:50.572Z","content":"\n一个可以快速搭建自己博客的工具\n\n\nHexo\n\nHexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。\n\n安装\n12$ npm install hexo$ npx hexo -version \n常用命令\n123$ unzip hexo.zip$ cd hexo$ ","thumbnail":"img/v07.jpeg","color":"#111","plink":"https://liuzy.love/2022/02/01/hexo/README/"},{"title":"小游戏","date":"2022-01-12T19:30:32.000Z","date_formatted":{"ll":"Jan 12, 2022","L":"01/12/2022","MM-DD":"01-12"},"updated":"2022-04-04T14:16:50.576Z","content":"","thumbnail":"img/game.jpg","color":"#111","plink":"https://liuzy.love/2022/01/12/mylife/小游戏/"},{"title":"生活笔记","date":"2022-01-12T18:39:35.000Z","date_formatted":{"ll":"Jan 12, 2022","L":"01/12/2022","MM-DD":"01-12"},"updated":"2022-04-04T14:16:50.576Z","content":"哇塞哇塞\n","thumbnail":"img/v04.jpeg","color":"#111","plink":"https://liuzy.love/2022/01/12/mylife/生活笔记/"},{"title":"go-切片","date":"2022-01-12T17:41:50.000Z","date_formatted":{"ll":"Jan 12, 2022","L":"01/12/2022","MM-DD":"01-12"},"updated":"2022-04-04T14:16:50.572Z","content":"\n《架构整洁之道》,软件架构的终极目标是，用最小的人力成本来满足构建和维护系统需求\n\n\n[toc]\narray\n数组声明的时候需要指定大小，例如\n1var array [10]int\n数组是值类型，并且大小是类型的一部分，例如\n1234var a = [3]int&#123;1, 2, 3&#125;fmt.Println(reflect.ValueOf(a).Type())// &gt;&gt;&gt; [3]int\n数组按照值传递方式，实际是传递的值副本\n12345678910111213func test(i [3]int) &#123;    // i的地址与a不一致&#125;func test1(i []int) &#123;&#125;func main() &#123;    var a = [3]int&#123;1, 2, 3&#125;    test(a) // 可以，i的地址与a不一致    test1(a) // 报错，因为类型不一致    test1(a[:]) // 可以，i的地址与a一致 &#125;\nslice\nslice并不是单纯的一个指向数组的指针，它是一个结构体（包含：指针，长度，容量）\n1make([]int, 4, 6)\n上述语句对应的slice结构如下，开辟了连续的6个int类型的地址空间，并初始化了前四个空间\n\nlen: slice中包含的元素数量\ncap: 从第一个元素开始，到其底层数据元素末尾的个数\nslice是否是引用传递？\nslice本身是一个结构体，slice本身是值传递，但是其指向的data是引用传递\nappend操作\n根据不同的场景，append之后如果：\n\nlen&gt;cap &amp;&amp; cap &lt;= 1024: 将从新开辟大小为2*cap的data地址空间\nlen&gt;cap &amp;&amp; cap &gt; 1024: 将从新开辟大小为1.25*cap的data地址空间，但根据内存对齐结果不是绝对的1.25\nlen&lt;cap data地址不变\n\n针对1，2，开辟新的data空间之后，将old空间的值拷贝过来，并将新的地址空间首地址赋值给data，原有地址空间不被破坏\n参考如下示例\n123456789101112131415161718192021222324package mainimport &quot;fmt&quot;func main() &#123;\tvar s = make([]int, 1, 2)\tprintSlice(s)\ts = append(s, 1)\tprintSlice(s)\ts = append(s, 1)\tprintSlice(s)&#125;func printSlice(s []int) &#123;\tfmt.Printf(&quot;len=%d cap=%d ptr=%d %v\\n&quot;, len(s), cap(s), &amp;s[0], s)&#125;/* outputlen=1 cap=2 ptr=824633836352 [0]len=2 cap=2 ptr=824633836352 [0 1]len=3 cap=4 ptr=824633819776 [0 1 1]*/\nNIL与空切片\n\nNILL的slice特指slice的data空间为nil，而slice本身对应的结构体是存在的\n\n声明一个NIL的slice，内部赋值如下\n1var s = []int\n\n声明一个(多个)空切片，内部赋值如下\n12var s1 = make([]int, 0)var s2 = make([]int, 0)\n\n通过上述描述，可以发现其底层机制不太一样，在具体的使用过程中的区别体现在\n12345678910111213141516var s1 []intvar s2 = make([]int, 0)s1 == nil # trues2 == nil # falselen(s1) == 0 # truelen(s2) == 0 # trues1 = append(s1, 1) // yess2 = append(s2, 1) // yesfor range s1 &#123;&#125; // yesfor rang s2 &#123;&#125; // yes\n \n另外，在json编码的时候会有区别\n1234var s1 []intvar s2 = make([]int, 0)json.Marshal(s1) // nulljson.Marshal(s2) // []\n切片\n\n上述示意图对应的代码示例如下：\n123456789101112131415func main() &#123;\tvar s = make([]int, 0, 6)\ts = append(s, 1, 2, 3, 4)\ts1 := s[:6]\ts2 := s[1:4]\ts3 := s[:0]\tfmt.Printf(&quot;s (addr: %p): %+8v\\n&quot;,\t\t&amp;s, *(*reflect.SliceHeader)(unsafe.Pointer(&amp;s)))\tfmt.Printf(&quot;s1 (addr: %p): %+8v\\n&quot;,\t\t&amp;s1, *(*reflect.SliceHeader)(unsafe.Pointer(&amp;s1)))\tfmt.Printf(&quot;s2 (addr: %p): %+8v\\n&quot;,\t\t&amp;s1, *(*reflect.SliceHeader)(unsafe.Pointer(&amp;s2)))\tfmt.Printf(&quot;s3 (addr: %p): %+8v\\n&quot;,\t\t&amp;s1, *(*reflect.SliceHeader)(unsafe.Pointer(&amp;s3)))&#125;\n\n特别注意，新的切片和原切片共享地址空间，注意写陷阱，例如s[2]=10 会同时影响s,s1,s2,s3\n\n浅拷贝和深拷贝\n浅拷贝\n浅拷贝参考上述切片\n深拷贝\n\n12345678910111213141516171819202122func main() &#123;\tvar s = []int&#123;1, 2, 3&#125;\tvar d = make([]int, 3)\tvar d1 = make([]int, 2)\tvar d2 = make([]int, 4)\tvar d4 []int\tvar d5 = make([]int, 0, 3)\tcopy(d, s)copy(d1, s)copy(d2, s)copy(d4, s)copy(d5, s)fmt.Printf(&quot;s (addr: %p)(v: %+v): %+8v\\n&quot;,\t&amp;s, s, *(*reflect.SliceHeader)(unsafe.Pointer(&amp;s)))fmt.Printf(&quot;d (addr: %p)(v: %+v): %+8v\\n&quot;,\t&amp;d, d, *(*reflect.SliceHeader)(unsafe.Pointer(&amp;d)))fmt.Printf(&quot;d1 (addr: %p)(v: %+v): %+8v\\n&quot;,\t&amp;d1, d1, *(*reflect.SliceHeader)(unsafe.Pointer(&amp;d1)))fmt.Printf(&quot;d2 (addr: %p)(v: %+v): %+8v\\n&quot;,\t&amp;d2, d2, *(*reflect.SliceHeader)(unsafe.Pointer(&amp;d2)))fmt.Printf(&quot;d4 (addr: %p)(v: %+v): %+8v\\n&quot;,\t&amp;d4, d4, *(*reflect.SliceHeader)(unsafe.Pointer(&amp;d4)))fmt.Printf(&quot;d5 (addr: %p)(v: %+v): %+8v\\n&quot;,\t&amp;d5, d5, *(*reflect.SliceHeader)(unsafe.Pointer(&amp;d5)))&#125;/*outputs  (addr: 0xc00000c060)(v: [1 2 3]):   &#123;Data:824633811360 Len:       3 Cap:       3&#125;d  (addr: 0xc00000c080)(v: [1 2 3]):   &#123;Data:824633811392 Len:       3 Cap:       3&#125;d1 (addr: 0xc00000c0a0)(v: [1 2]):     &#123;Data:824633827472 Len:       2 Cap:       2&#125;d2 (addr: 0xc00000c0c0)(v: [1 2 3 0]): &#123;Data:824633811424 Len:       4 Cap:       4&#125;d4 (addr: 0xc00000c0e0)(v: []):        &#123;Data:           0 Len:       0 Cap:       0&#125;d5 (addr: 0xc00000c100)(v: []):        &#123;Data:824633811456 Len:       0 Cap:       3&#125;*/\nvar s = []int, var s = make([]int, 0, 3) 都会导致拷贝失效，因为copy是基于目的列表的Len进行拷贝 实际中的深拷贝要复杂的多,\n参考如下代码\n1gotype S struct &#123;\tA []int\tB []string&#125;func main() &#123;\tvar src = []S&#123;&#123;A: []int&#123;1&#125;, B: []string&#123;&quot;B&quot;&#125;&#125;&#125;\tvar dest = make([]S, 1)\tcopy(dest, src)\tfmt.Printf(&quot;src       (addr: %p): %+8v\\n&quot;,\t\t&amp;src, *(*reflect.SliceHeader)(unsafe.Pointer(&amp;src)))\tfmt.Printf(&quot;dest      (addr: %p): %+8v\\n&quot;,\t\t&amp;dest, *(*reflect.SliceHeader)(unsafe.Pointer(&amp;dest)))\tfmt.Printf(&quot;src[0].A  (addr: %p): %+8v\\n&quot;,\t\t&amp;src[0].A, *(*reflect.SliceHeader)(unsafe.Pointer(&amp;src[0].A)))\tfmt.Printf(&quot;dest[0].A (addr: %p): %+8v\\n&quot;,\t\t&amp;dest[0].A, *(*reflect.SliceHeader)(unsafe.Pointer(&amp;dest[0].A)))&#125;/*outputsrc       (addr: 0xc0000a6020): &#123;Data:824634311040 Len:       1 Cap:       1&#125;dest      (addr: 0xc0000a6040): &#123;Data:824634311088 Len:       1 Cap:       1&#125;src[0].A  (addr: 0xc000090180): &#123;Data:824634458120 Len:       1 Cap:       1&#125;dest[0].A (addr: 0xc0000901b0): &#123;Data:824634458120 Len:       1 Cap:       1&#125;*/\n \n虽然对src进行了深拷贝，但是src和dest中A和B指向了同一个地址空间，因此针对复杂类型的slice，需要自定义深拷贝方法。\n1234567891011121314151617181920212223242526272829303132type S struct &#123;\tA []int\tB []string&#125;func (s S) deepCopy() S &#123;\tdest := S&#123;\t\tA: make([]int, len(s.A)),\t\tB: make([]string, len(s.B)),\t&#125;\tcopy(dest.A, s.A)\tcopy(dest.B, s.B)\treturn dest&#125;func main() &#123;\tvar src = []S&#123;&#123;A: []int&#123;1&#125;, B: []string&#123;&quot;B&quot;&#125;&#125;&#125;\tvar dest = make([]S, 1)\tdest[0] = src[0].deepCopy()\tfmt.Printf(&quot;src       (addr: %p): %+8v\\n&quot;,\t&amp;src, *(*reflect.SliceHeader)(unsafe.Pointer(&amp;src)))fmt.Printf(&quot;dest      (addr: %p): %+8v\\n&quot;,\t&amp;dest, *(*reflect.SliceHeader)(unsafe.Pointer(&amp;dest)))fmt.Printf(&quot;src[0].A  (addr: %p): %+8v\\n&quot;,\t&amp;src[0].A, *(*reflect.SliceHeader)(unsafe.Pointer(&amp;src[0].A)))fmt.Printf(&quot;dest[0].A (addr: %p): %+8v\\n&quot;,\t&amp;dest[0].A, *(*reflect.SliceHeader)(unsafe.Pointer(&amp;dest[0].A)))&#125;/*outputsrc       (addr: 0xc0000a6020): &#123;Data:824634311040 Len:       1 Cap:       1&#125;dest      (addr: 0xc0000a6040): &#123;Data:824634311088 Len:       1 Cap:       1&#125;src[0].A  (addr: 0xc000090180): &#123;Data:824634458120 Len:       1 Cap:       1&#125;dest[0].A (addr: 0xc0000901b0): &#123;Data:824634458128 Len:       1 Cap:       1&#125;*/\n可以看到，src[0].A和dest[0].B指向了不同的地址空间## 清空slice方法1\n1govar s = []int&#123;1,2,3&#125;s = nil // GC机制自动回收fmt.Println(s, len(s), cap(s)) // [], 0, 0s1 = s1[:0]\n方法2\n1var s1 = []int&#123;1,2,3&#125;fmt.Println(s1, len(s1), cap(s1)) // [], 0, 3\n根据需求，如果还需要继续使用slice底层内存，就选择方法2\nrange中修改元素\n根据不同的使用方式，range的实现原理如下：\n场景1 for index, value := range s &#123;&#125;\n1// The loop we generate:   for_temp := range   len_temp := len(for_temp)   for index_temp = 0; index_temp &lt; len_temp; index_temp++ &#123;           value_temp = for_temp[index_temp]           index = index_temp           value = value_temp           original body   &#125;\n\n遍历时已经确定了index的范围(0,1,2,…,len_temp)\n遍历时会将slice赋值给临时变量(for_temp)\n\n场景2 for index := range s &#123;&#125;\n1// The loop we generate:   len_temp := len(for_temp)   for index_temp = 0; index_temp &lt; len_temp; index_temp++ &#123;           index = index_temp           original body   &#125;\n\n遍历时已经确定了index的范围(0,1,2,…,len_temp)\n\n针对for index, value := range s &#123;&#125;的场景，我们看下slice赋值的时候发生了什么？\n\n图对对应的代码如下：\n1func main() &#123;\tvar s = []int&#123;1, 2, 3&#125;\tvar d = s\tfmt.Printf(&quot;s (addr: %p): %+8v\\n&quot;,\t\t&amp;s, *(*reflect.SliceHeader)(unsafe.Pointer(&amp;s)))\tfmt.Printf(&quot;d (addr: %p): %+8v\\n&quot;,\t\t&amp;d, *(*reflect.SliceHeader)(unsafe.Pointer(&amp;d)))\tfmt.Println(&quot;----------------------------------&quot;)\ts = s[:2]\tfmt.Printf(&quot;s (addr: %p): %+8v\\n&quot;,\t\t&amp;s, *(*reflect.SliceHeader)(unsafe.Pointer(&amp;s)))\tfmt.Printf(&quot;d (addr: %p): %+8v\\n&quot;,\t\t&amp;d, *(*reflect.SliceHeader)(unsafe.Pointer(&amp;d)))&#125;/*outputs (addr: 0xc00000c060): &#123;Data:824633811360 Len:       3 Cap:       3&#125;d (addr: 0xc00000c080): &#123;Data:824633811360 Len:       3 Cap:       3&#125;----------------------------------s (addr: 0xc00000c060): &#123;Data:824633811360 Len:       2 Cap:       3&#125;d (addr: 0xc00000c080): &#123;Data:824633811360 Len:       3 Cap:       3&#125;*/\n\n赋值之后s和d是两个变量，但是指向了同一个地址空间. 修改s(不修改data)，不会影响d\n\n根据上述原理，我们看几个例子\n1func main() &#123;\tvar s = []int&#123;1, 2, 3&#125;\tfor index := range s &#123;\t\tif s[index] == 2 &#123;\t\t\ts = s[:2]\t\t&#125;\t\t_ = s[index]\t&#125;&#125;/*代码符合场景2，代码会直接panic，遍历时指向的是原有的s，此时s的长度变成了2，当index=2时会引起panic*/\n1func main() &#123;\tvar s = []int&#123;1, 2, 3&#125;\tfor index, value := range s &#123;\t\tif value == 2 &#123;\t\t\ts = s[:2]\t\t&#125;\t\tfmt.Println(index, value)\t&#125;&#125;/*0 11 22 3*/// 代码符合场景1，因为内部已经拷贝了s为for_temp(len=3)，s=s[:2]不会改变for_temp, 因此可以遍历到原s的所有值\n如果上述原理已经理解，则如下代码的输出应该能够很快给出\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110// T1 测试遍历slice的时候，动态append的影响/*output[1 2 1 2 1 2 1 2]*/func T1() &#123;\tvar s = []int&#123;1, 2&#125;\tfor range s &#123;\t\ts = append(s, s...)\t&#125;\tfmt.Println(s)&#125;// T2 测试遍历slice的时候，动态append的影响/*output[1 2 1 2]*/func T2() &#123;\tvar s = []int&#123;1, 2&#125;\tfor index := range s &#123;\t\ts = append(s, s[index])\t&#125;\tfmt.Println(s)&#125;// for index := range s &#123;&#125;// T3 测试如上的遍历方式下，动态删除数组元素的影响/*output13panic*/func T3() &#123;\tvar s = []int&#123;1, 2, 3&#125;\tfor index := range s &#123;\t\tif index == 1 &#123;\t\t\ts = append(s[:index], s[index+1:]...)\t\t&#125;\t\tfmt.Println(s[index])\t&#125;&#125;// for index, value := range s &#123;&#125;// T4 测试如上的遍历方式下，动态删除数组元素的影响/*output13panic*/func T4() &#123;\tvar s = []int&#123;1, 2, 3&#125;\tfor index, value := range s &#123;\t\tif value == 2 &#123;\t\t\ts = append(s[:index], s[index+1:]...)\t\t&#125;\t\tfmt.Println(s[index])\t&#125;&#125;// for index, value := range s &#123;&#125;// T5 测试如上的遍历方式下，动态删除数组元素的影响/*output123*/func T5() &#123;\tvar s = []int&#123;1, 2, 3&#125;\tfor index, value := range s &#123;\t\tif value == 2 &#123;\t\t\ts = append(s[:index], s[index+1:]...)\t\t&#125;\t\tfmt.Println(value)\t&#125;&#125;// for index, value := range s &#123;&#125;// T6 测试如上的遍历方式下，动态修改s/*output123*/func T6() &#123;\tvar s = []int&#123;1, 2, 3&#125;\tfor index, value := range s &#123;\t\tif index == 1 &#123;\t\t\ts = []int&#123;4, 5, 6&#125;\t\t&#125;\t\tfmt.Println(value)\t&#125;&#125;// for index, value := range s &#123;&#125;// T7 测试如上的遍历方式下，动态删除数组元素的影响/*output1 110 23 3*/func T7() &#123;\tvar s = []int&#123;1, 2, 3&#125;\tfor index, value := range s &#123;\t\tif index == 1 &#123;\t\t\ts[index] = 10\t\t&#125;\t\tfmt.Println(s[index], value)\t&#125;&#125;\n优化建议\n建议1\n如果非常明确数组的大小，则应该采用如下的方式声明，避免：\n\n防止append时多次申请内存并减低GC压力；\n防止大小不固定引起的内存漂移；\n\n建议的方式：\n12345var s = []int&#123;1,2,3&#125;var d = make([]string, len(s)) // 一次性分配连续内存；栈上分配内存，无需GCfor index ：= range s &#123;    d[index] = &quot;any&quot;&#125;\n不建议的方式：\n12345var s = []int&#123;1,2,3&#125;var d = make([]string, 0) // 编译阶段无法确定大小，内存漂移到堆上，需要GCfor range s &#123;    d = append(d, &quot;any&quot;) // 每次append都会引起新的内存分配以及老的内存回收&#125;\n建议2\n遍历方式的优化\n12345678910// 建议的方式，避免值拷贝for index := range s&#123;    _ = s[index]&#125;// 不建议的方式// value在内部进行了一次值拷贝for _, value := range s&#123;    _ = value&#125;\n","thumbnail":"img/golang.png","color":"#111","plink":"https://liuzy.love/2022/01/12/go/go笔记/go-切片/"},{"title":"《架构整洁之道》读书笔记","date":"2022-01-12T17:39:31.000Z","date_formatted":{"ll":"Jan 12, 2022","L":"01/12/2022","MM-DD":"01-12"},"updated":"2022-04-04T14:16:50.576Z","content":"\n《架构整洁之道》,软件架构的终极目标是，用最小的人力成本来满足构建和维护系统需求\n\n\n第1章 设计与架构究竟是什么\n\n软件架构的终极目标是，用最小的人力成本来满足构建和维护系统需求\n\n第2章 两个价值维度\n\n对于软件系统，我们通过行为和架构来体现他的价值。\n\n\n行为价值：实现的功能\n架构：软件的灵活性\n\n\n构建一个灵活性高的软件，比短时间内能实现需求更为重要\n软件开发人员应当在保证软件架构的前提下去完成紧急的需求\n软件架构师的职责：构建出易于开发、修改简单、扩展轻松的架构\n\n第3章 编程范式总览\n\n结构化编程\n面向对象编程\n函数式编程\n\n第4章 结构化编程\n\n结构化编程范式促使我们将一段程序递归降解为一系列可证明的小函数，然后再编写相关测试用例来证明这些函数是错误的。若无法证明这些函数是错误的，那么我们认为这些函数是足够正确的，进而推导整个程序是正确的。\n在架构设计领域，功能性降解拆分是非常重要的\n\n第5章 面向对象编程\n\n面向对象编程的核心本职是对多态的运用，利用多态的特性对代码中依赖关系进行控制。这种能力让软件架构师可以构建出某种插件式架构，让高层策略性组将与底层实现性组件进行分离，底层组件可以被编译成插件，实现独立于高层组件的开发与部署。\n多态是同一个行为拥有不同表现形式或形态的能力。多态的表现形式包括虚函数的重写、接口实现、抽象方法等。\n\n第6章 函数式编程\n\nTODO:\n\n第7章 SRP:单一职责原则\n\n任何一个软件模块都应该只对某一类行为者负责。\n例如合同订单中的下单接口，API和页面调用的Service应该分开，保证职责单一。DA层只是单纯做新增则可重用。出现过一次修改页面下单Service，导致API下单报错线上事故，获取创建人是从上下文中获取的，导致API接口获取不到创建人，API接口没有上下文，是直接在InUserSysNo中赋值。\n\n第8章 OCP：开闭原则\n\n设计良好的软件应该易于扩展，同时抗拒修改。主要目标是让系统易于扩展，限制每次修改所影响的范围。\n实现方式是把系统拆分为一系列组件，并且将这些组件的依赖关系按层次结构进行组织，使得上层组件不会因为低阶组件的修改而受到影响。\n\n第9章 LSP:里氏替换原则\n\n主要表达实现类有可替换性，即对接口的合理使用。\n\n第10章 ISP:接口隔离原则\n\n不要依赖程序不要的东西。一但所依赖的东西有所修改都可能会影响到主程序。\n\n第11章 DIP:依赖反转原则\n\n如果想要设计一个灵活的系统，在源代码层次的依赖关系中应该多引用抽象，而非具体实现。\n\n第12章 组件\n\n可独立部署的最小实体\n\n第13章 组件聚合\n\n共同闭包原则（CCP）：我们将那些会同时修改，并且为相同目的而修改的类放到同一个组件中，而将不会同时修改，并且不会为了相同目的而修改的那些类放到不同的组件中。\n\n第14章 组件耦合\n\n组件依赖关系图中不应该出现环\n在依赖图中没有环装结构图则称这种图为有向无环图（DAG）\n消除循环依赖有两种方式：\n\n依赖反转。若存在循环依赖A&gt;B&gt;C&gt;D&gt;B，可在B中定义接口，C实现接口，则依赖关系变为A&gt;B&lt;C\n共同依赖一个新组件，这也是spring框架中控制反转(IOC) 的就是使用此方法。若存在循环依赖A&gt;B&gt;C&gt;D&gt;B，可定义新组件E，让B和C同时依赖E,则依赖关系变为A&gt;B&gt;E&lt;C\n\n\n稳定依赖原则（SDP）：依赖关系必须时指向更稳定的方向。通过遵守稳定依赖原则，我们可以确保自己的设计中那些容易变更的模块不会被难以修改的模块依赖。\n稳定抽象原则（SAP）：一个组件的抽象化程度应该与其稳定性保持一致。一个稳定的组件应该是抽象的，一个不稳定的组件应该包含实现代码，这样便于修改。\n一个好的组件一定是由抽象类/接口、实现方法组成，需要保持其中的平衡。全为接口则无用，应该包含部分实现。\n\n第15章 什么是软件架构\n\n软件架构这项工作的实质就是规划如何将系统拆分为组件，并安排组件之间的排序关系，以及组件之间相互通信的方式。\n设计软件架构的目的是为了在工作中更好的对这些组件进行研发、部署、运行以及维护。\n\n第16章 独立性\n\n按层解耦：\n\n可以通过采用单一职责原则（SRP）和共同闭包原则（CCP）以及既定的系统设计意图来隔离那些变更原因不同的部分，集成变更原因相同的部分。\n一个系统可以被解耦成若干个系统分层：UI界面、应用独有的业务逻辑、领域普适的业务逻辑、数据库\n\n\n\n第17章 划分边界\n\n为了在软件架构中划分边界，我们需要将系统拆分为组件，其中一部分是系统的核心业务逻辑组件，一部分时非核心业务逻辑组件但是是需要提供必要功能的插件，通过依赖反转原则（DIP）和稳定抽象原则（SAP）的运用让非核心功能插件依赖核心组件。例如UI层需要依赖业务逻辑层，但UI层可作为插件可随意切换为WEB、移动端、客户端等，数据的存储同样如此，核心逻辑并不关系数据存储在数据库或文件，只要具体实现类去实现核心逻辑定义的借口即可。\n\n第18章 边界剖析\n\n一个按照服务划分边界的系统也可能会在某一部分采用本地进程的边界划分模式。\n\n第19章 策略和层次\n\n我们对“层次”时严格按照“输入与输出之间的距离”来定义的。也就是说，一条策略距离系统的输入/输出越远，它所处的层次就越高。而直接管理系统的输入/输出的策略在系统中的层次时最低的。\n\n第20章 业务逻辑\n\n业务逻辑时系统中最核心的代码，应该保持纯净，不掺杂任何用户界面或所使用数据库相关的东西。其他底层概念的实现应该以差价的形式接入系统中。业务逻辑应该是系统中最独立、复用性最高的代码。\n\n","thumbnail":"https://images.unsplash.com/photo-1470211702316-05678b58d67a?fit=crop&w=1280&h=720&q=80","color":"#111","plink":"https://liuzy.love/2022/01/12/mylife/《架构整洁之道》读书笔记/"},{"title":"ProfessionalKnowledge","date":"2022-01-01T18:00:00.000Z","date_formatted":{"ll":"Jan 1, 2022","L":"01/01/2022","MM-DD":"01-01"},"updated":"2022-04-04T14:16:50.572Z","content":"\n没有总结的知识终究会被遗忘，这里将记录一些技术相关的文档，包括算法、开发语言、中间件、docker、k8s等技术性文件\n\n\nProfessionalKnowledge\n\n专业知识总结记录\n\ngo\n\ngolang语言技术栈知识总结\n\nJava\n\nJava语言\n\nleetcode\n\n算法练习\n\nmysql\n\n数据库知识\n\nmarkdown\n\nmarkdown文件使用及其模板，方便快速编写及排版文档\n\n\n入门模板.md 一些常见的语法\n简单模板.md 简单的markdown示例\n语法示例大全.md 比较全都markdown语法示例\n\n","color":"#539bf5","plink":"https://liuzy.love/2022/01/01/README/"},{"title":"Docker","date":"2022-01-01T18:00:00.000Z","date_formatted":{"ll":"Jan 1, 2022","L":"01/01/2022","MM-DD":"01-01"},"updated":"2022-04-04T14:16:50.572Z","content":"\ndocker\n\n\nDocker\n","color":"#539bf5","plink":"https://liuzy.love/2022/01/01/docker/README/"},{"title":"Go","date":"2022-01-01T18:00:00.000Z","date_formatted":{"ll":"Jan 1, 2022","L":"01/01/2022","MM-DD":"01-01"},"updated":"2022-04-04T14:16:50.572Z","content":"\ngolang语言技术栈知识总结\n\n\ngo\n\ngolang语言技术栈知识总结；初次系统的去学习golang时，我选择了【go语言设计与实现】[^go语言设计与实现]\n\n[^go语言设计与实现]: 【go语言设计与实现】参考文档 对于小白的本人，选择了学习golang的第一本书！\n","color":"#539bf5","plink":"https://liuzy.love/2022/01/01/go/README/"},{"title":"Java","date":"2022-01-01T18:00:00.000Z","date_formatted":{"ll":"Jan 1, 2022","L":"01/01/2022","MM-DD":"01-01"},"updated":"2022-04-04T14:16:50.576Z","content":"\nJava语言\n\n\nJava\n","color":"#539bf5","plink":"https://liuzy.love/2022/01/01/java/README/"},{"title":"Kubernetes","date":"2022-01-01T18:00:00.000Z","date_formatted":{"ll":"Jan 1, 2022","L":"01/01/2022","MM-DD":"01-01"},"updated":"2022-04-04T14:16:50.576Z","content":"\nK8s\n\n\nKubernetes\n\nK8s\n\n","color":"#539bf5","plink":"https://liuzy.love/2022/01/01/kubernetes/README/"},{"title":"LeetCode","date":"2022-01-01T18:00:00.000Z","date_formatted":{"ll":"Jan 1, 2022","L":"01/01/2022","MM-DD":"01-01"},"updated":"2022-04-04T14:16:50.576Z","content":"\n算法练习\n\n\nLeetCode\n目录\n4【寻找两个正序数组的中位数】\n\n核心：中位数计算方式\n\n偏移量k = (num1.len+num2.len)/2 + (num1.len+num2.len)%2\n中位half = k/2\n\n\n5【最长回文子串】\n\n核心：中心对称寻找法\n回文字符串：就是中心对称字符串，如：aba，abba，abccba\n\n1.基数对称：121，12321\n2.偶数对称：11，1221\n空间复杂O(n),时间复杂度O($n^2$)\n\n\n6【Z 字形变换】\n\n核心：每一层之间数据间隔的规律\n3层：4 0/ 2 2/ 4 0\n4层：6 0/ 4 2/ 2 4/ 6 0\n\n7【整数反转】\n\n核心：\n\n8【字符串转换整数 (atoi)】\n\n核心：\n\n","color":"#539bf5","plink":"https://liuzy.love/2022/01/01/leetcode/README/"},{"title":"MarkDown","date":"2022-01-01T18:00:00.000Z","date_formatted":{"ll":"Jan 1, 2022","L":"01/01/2022","MM-DD":"01-01"},"updated":"2022-04-04T14:16:50.576Z","content":"\nmarkdown文件使用及其模板，方便快速编写及排版文档\n\n\nmarkdown\n\n入门模板.md 一些常见的语法\n简单模板.md 简单的markdown示例\n语法示例大全.md 比较全都markdown语法示例\n\n","color":"#539bf5","plink":"https://liuzy.love/2022/01/01/markdown/README/"},{"title":"Mysql","date":"2022-01-01T18:00:00.000Z","date_formatted":{"ll":"Jan 1, 2022","L":"01/01/2022","MM-DD":"01-01"},"updated":"2022-04-04T14:16:50.576Z","content":"\nMySQL相关的学习文件\n\n\nmysql\n\n数据库知识\n\n","color":"#539bf5","plink":"https://liuzy.love/2022/01/01/mysql/README/"},{"title":"shell命令","date":"2022-01-01T18:00:00.000Z","date_formatted":{"ll":"Jan 1, 2022","L":"01/01/2022","MM-DD":"01-01"},"updated":"2022-04-04T14:16:50.576Z","content":"\n常用的shell命令\n\n\n","color":"#539bf5","plink":"https://liuzy.love/2022/01/01/shell/README/"},{"title":"About","date":"2016-04-21T04:48:33.000Z","updated":"2022-04-04T14:16:50.564Z","content":""}]